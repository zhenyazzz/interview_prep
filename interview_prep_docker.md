## Docker

1. [What is the essence of Docker and what problem does it solve?](#вопрос-1-what-is-the-essence-of-docker-and-what-problem-does-it-solve)
2. [Describe in general terms what should be in the .Dockerfile](#вопрос-2-describe-in-general-terms-what-should-be-in-the-dockerfile)
3. [What is docker-compose and why is it needed?](#вопрос-3-what-is-docker-compose-and-why-is-it-needed)
4. [What are layers in images and what problem do they solve?](#вопрос-4-what-are-layers-in-images-and-what-problem-do-they-solve)
5. [What types of networks does docker-compose allow you to install for services?](#вопрос-5-what-types-of-networks-does-docker-compose-allow-you-to-install-for-services)
6. [Case: I launched PostgreSQL in docker, but it is not available on the system via standard port 5432. Where to look and how to diagnose?](#вопрос-6-case-i-launched-postgresql-in-docker-but-it-is-not-available-on-the-system-via-standard-port-5432-where-to-look-and-how-to-diagnose)

---

### Вопрос 1. What is the essence of Docker and what problem does it solve?

#### 1.1. Суть Docker в одном предложении

**Docker = лёгкие контейнеры**, которые упаковывают приложение **вместе со всеми зависимостями** (runtime, библиотеки, системные утилиты), чтобы оно **одинаково работало в любой среде**: на ноутбуке, в CI, на проде.

Без Docker:
- на машине разработчика одна версия Java/Postgres/Node,
- на сервере — другая,
- плюс отличия ОС и настроек → "у меня работает, у вас нет".

Контейнер даёт:
- своё изолированное окружение (файловая система образа, свои либы, свои порты);
- при этом использует **общее ядро ОС**, без тяжёлой виртуалки.

---

#### 1.2. Контейнер vs виртуальная машина

**Виртуальная машина (VM)**:
- своя полная гостевая ОС;
- гипервизор (VirtualBox, VMware, KVM и т.п.);
- тяжёлая по ресурсам, медленный старт.

**Контейнер**:
- делит ядро хостовой ОС;
- изоляция через namespaces/cgroups;
- старт за миллисекунды/секунды;
- гораздо легче по потреблению памяти и диска.

Итог:
- ВМ хороша, когда нужна полная изоляция и разные ОС;
- контейнеры — когда важна скорость старта, плотность и предсказуемость окружения.

---

#### 1.3. Какие проблемы решает Docker

- **Повторяемость окружения**:
  - все зависимости описаны в `Dockerfile` и образе;
  - один и тот же образ ведёт себя одинаково везде.

- **Изоляция зависимостей**:
  - разные сервисы могут иметь разные runtime/версии либ (Python, Java, Node) на одном хосте;
  - они не конфликтуют между собой.

- **Простой деплой и масштабирование**:
  - образ — это артефакт: `docker run image` где угодно;
  - легко поднять несколько инстансов одного сервиса.

- **Интеграционные окружения**:
  - локально поднимаешь весь стек (приложение + БД + кэш и т.п.) без установки всего этого в систему.

---

### Вопрос 2. Describe in general terms what should be in the .Dockerfile

`Dockerfile` — это рецепт, как собрать образ. В общих чертах:

1. **Базовый образ** (`FROM`).
2. **Рабочая директория** (`WORKDIR`).
3. **Копирование кода и конфигов** (`COPY`/`ADD`).
4. **Установка зависимостей / сборка** (`RUN`).
5. **Переменные окружения** (`ENV`).
6. **Открываемые порты** (`EXPOSE`).
7. **Команда запуска** (`CMD` / `ENTRYPOINT`).
8. (Опционально) тома (`VOLUME`), `HEALTHCHECK`, multi-stage build и т.п.

---

#### 2.1. FROM — базовый образ

```dockerfile
FROM openjdk:17-jdk-slim
```

- определяет базовую ОС и предустановленный софт (JDK, Python, Node и т.п.);
- всегда первая инструкция.

---

#### 2.2. WORKDIR — рабочая директория

```dockerfile
WORKDIR /app
```

- все дальнейшие команды (`RUN`, `COPY`, `CMD`) по умолчанию выполняются относительно этой директории.

---

#### 2.3. COPY / ADD — копирование файлов

```dockerfile
COPY pom.xml /app/
COPY src /app/src
```

- копирует файлы с хоста в образ;
- обычно достаточно `COPY` (без лишней магии `ADD`).

---

#### 2.4. RUN — установка зависимостей и сборка

```dockerfile
RUN apt-get update && apt-get install -y curl
RUN mvn -f /app/pom.xml package -DskipTests
```

- выполняет команды **на этапе сборки образа**;
- используют для установки пакетов ОС, сборки артефактов, чистки мусора.

Каждый `RUN` — новый слой; команды обычно объединяют:

```dockerfile
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
```

---

#### 2.5. EXPOSE — документирование порта

```dockerfile
EXPOSE 8080
```

- указывает, на каком порту приложение слушает внутри контейнера;
- сам по себе порт не публикует наружу, но важен для документации и `docker run -P`.

---

#### 2.6. ENV — переменные окружения

```dockerfile
ENV SPRING_PROFILES_ACTIVE=prod
ENV JAVA_OPTS="-Xms256m -Xmx512m"
```

- задаёт значения env-переменных внутри контейнера;
- можно переопределять при запуске (`docker run -e`, docker-compose).

---

#### 2.7. CMD / ENTRYPOINT — команда запуска

Примеры:

```dockerfile
CMD ["java", "-jar", "app.jar"]
```

или:

```dockerfile
ENTRYPOINT ["java", "-jar", "app.jar"]
```

- `CMD` — команда по умолчанию (можно переопределить при запуске);
- `ENTRYPOINT` — "жёсткая" точка входа, поверх которой можно менять только аргументы.

Часто делают:

```dockerfile
ENTRYPOINT ["java", "-jar", "app.jar"]
```

а параметры JVM/профили прокидывают через `ENV`/`CMD`.

---

### Вопрос 3. What is docker-compose and why is it needed?

#### 3.1. Что такое docker-compose

**docker-compose** — это утилита, которая позволяет описать **несколько контейнеров как один проект** в YAML-файле `docker-compose.yml` и запускать их одной командой.

Проблема без него:
- каждый контейнер надо стартовать через длинный `docker run` с кучей флагов (`-p`, `-v`, `-e`, `--network` и т.д.);
- для нескольких сервисов (app + db + redis + mq) это превращается в ад.

С docker-compose:
- описываешь всё один раз в YAML-е;
- запускаешь `docker-compose up -d` и получаешь весь стек.

---

#### 3.2. Пример структуры `docker-compose.yml`

```yaml
version: "3.9"

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=dev
    depends_on:
      - db

  db:
    image: postgres:14
    environment:
      - POSTGRES_USER=app
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=appdb
    ports:
      - "5432:5432"
    volumes:
      - db-data:/var/lib/postgresql/data

volumes:
  db-data:
```

Основные элементы:
- `services` — список контейнеров (сервисов) с их настройками;
- у каждого сервиса можно описать:
  - образ или `build`,
  - порты,
  - переменные окружения,
  - тома,
  - сети,
  - зависимости (`depends_on`);
- `volumes`/`networks` — общие тома и сети для проекта.

---

#### 3.3. Зачем нужен docker-compose

- **Удобная локальная разработка**:
  - один YAML — весь стек (app + db + cache + …);
  - не нужно ставить Postgres/Redis на хост.

- **Повторяемость окружения**:
  - любой разработчик может поднять то же самое `docker-compose up`;
  - подходит для интеграционных стендов, тестов.

- **Упрощённая оркестрация**:
  - связка сервисов с сетями, томами, зависимостями;
  - удобные команды: `up`, `down`, `logs`, `restart`, `scale`.


### Вопрос 4. What are layers in images and what problem do they solve?

#### 4.1. Что такое слои (layers) в образах

Docker-образ — это **набор слоёв**, каждый слой:
- соответствует одной или нескольким инструкциям Dockerfile (`FROM`, `RUN`, `COPY`, etc.);
- является **read-only** слоем файловой системы;
- при сборке новый слой "накладывается" поверх предыдущих.

При запуске контейнера:
- поверх слоёв образа создаётся **верхний writable-слой** (copy-on-write), куда пишутся изменения.

---

#### 4.2. Зачем нужны слои

1. **Кэширование сборки (build cache)**:
   - если слой уже был собран с теми же входными данными, Docker его **повторно использует**;
   - при изменении только последних инструкций, предыдущие слои не пересобираются.

Пример:

```dockerfile
FROM openjdk:17-jdk-slim
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn package -DskipTests
```

- если ты поменяешь только код в `src`, слои до `COPY src` останутся в кэше;
- зависимостям (`mvn dependency:go-offline`) не нужно качаться заново.

2. **Повторное использование между образами**:
   - если два образа используют один и тот же базовый слой (`FROM openjdk:17-jdk-slim`), он будет **храниться один раз**;
   - экономия места в registry/на диске.

3. **Быстрый pull/push**:
   - при обновлении образа докачиваются/отправляются только изменившиеся слои.

---

#### 4.3. Практические выводы

- Чем меньше и "умнее" слоёв, тем:
  - быстрее пересборка;
  - меньше трафик до registry;
  - меньше дубликатов в хранилище.

- Поэтому:
  - группируют команды `RUN` (но не до идиотизма);
  - сначала копируют файлы с зависимостями (`pom.xml`, `package.json`) и ставят deps;
  - затем копируют исходники, чтобы не ломать кэш на зависимостях при каждом изменении кода.

---

#### 4.4. Как ответить на собесе

- "Слои в Docker-образе — это последовательность read-only слоёв файловой системы, соответствующих инструкциям Dockerfile. Они позволяют переиспользовать общие части образов и агрессивно кэшировать сборку: если слои не изменились, Docker не пересобирает их и не перекачивает, что ускоряет сборку, уменьшает размер и трафик."

---

### Вопрос 5. What types of networks does docker-compose allow you to install for services?

#### 5.1. Базовая идея сетей в Docker / docker-compose

- По умолчанию docker-compose создаёт **отдельную bridge-сеть** для проекта:
  - все сервисы внутри `docker-compose.yml` попадают в одну сеть;
  - они могут обращаться друг к другу по имени сервиса (`db`, `app` и т.д.).

В `docker-compose.yml` можно явно описывать сети:

```yaml
services:
  app:
    ...
    networks:
      - backend
      - frontend

  db:
    ...
    networks:
      - backend

networks:
  backend:
    driver: bridge
  frontend:
    driver: bridge
```

---

#### 5.2. Основные типы сетей (drivers)

На уровне Docker обычно доступны такие drivers:

- **bridge**:
  - дефолтный тип для контейнеров на Linux;
  - контейнеры получают IP в виртуальной сети Docker;
  - с хоста к ним можно достучаться по проброшенным портам (`-p`).

- **host**:
  - контейнер **делит сетевой стек с хостом**;
  - нет отдельного IP, использует IP хоста;
  - порты внутри и снаружи совпадают (нет `-p`, всё "как на хосте").

- **none**:
  - у контейнера **нет** сетевого стека (никакого сетевого доступа);

- (дополнительно) `overlay`, `macvlan` и др. — используются выше в swarm/k8s/сложных конфигурациях.

В docker-compose чаще всего используешь:

```yaml
networks:
  mynet:
    driver: bridge
```

И реже:

```yaml
services:
  app:
    network_mode: host
```

---

#### 5.3. Для чего это нужно в compose

- Разделение на **внутренние и внешние сети**:
  - `backend` — только для общения сервисов (app, db, redis);
  - `frontend` — для nginx/прокси, который доступен снаружи.

- Управление доступом:
  - сервис в одной сети не видит контейнеры другой сети, если их не связать.

---

#### 5.4. Как ответить на собесе

- "В docker-compose можно описывать сети и подключать сервисы к одной или нескольким из них. Чаще всего используются сети с driver `bridge` (отдельная виртуальная сеть для проекта), реже `host` (контейнер делит сетевой стек с хостом) и `none` (без сети). Это нужно, чтобы разделять внутренний трафик между сервисами и управлять тем, кто к кому имеет доступ."

---

### Вопрос 6. Case: I launched PostgreSQL in docker, but it is not available on the system via standard port 5432. Where to look and how to diagnose?

Разбираем кейс по шагам — **куда смотреть и что проверять**.

#### 6.1. Проверить, что контейнер вообще живой

```bash
docker ps
```

- Убедиться, что контейнер с Postgres:
  - запущен;
  - не падает сразу после старта (если он в `Exited`, смотреть логи).

Логи:

```bash
docker logs <container_name_or_id>
```

Ищем:
- ошибки инициализации,
- права на тома,
- конфиги и т.п.

---

#### 6.2. Проверить проброс портов (host:container)

Если запускаешь через `docker run`:

```bash
docker run -d --name pg \
  -e POSTGRES_PASSWORD=secret \
  -p 5432:5432 \
  postgres:14
```

- первая цифра (`5432:5432`) — **порт на хосте**,
- вторая — **порт внутри контейнера**.

Проверить, как на самом деле проброшено:

```bash
docker ps
```

В колонке `PORTS` должно быть что-то вроде:
- `0.0.0.0:5432->5432/tcp` или `*:5432->5432/tcp`.

Если там пусто или другой порт:
- значит, порт не проброшен / проброшен не на 5432.

В docker-compose:

```yaml
services:
  db:
    image: postgres:14
    ports:
      - "5432:5432"
```

Проверь, что там именно `"5432:5432"`, а не `"5433:5432"` и т.п.

---

#### 6.3. Проверить, что Postgres слушает внутри контейнера

Зайти внутрь контейнера:

```bash
docker exec -it <container_name> bash
```

Посмотреть, слушает ли Postgres порт 5432:

```bash
ss -tnlp | grep 5432
# или
netstat -tnlp | grep 5432
```

Ожидаем что-то вроде:
- `LISTEN 0 128 0.0.0.0:5432 ... postgres`

Если Postgres слушает только `127.0.0.1` внутри контейнера — для доступа снаружи это обычно не мешает, важен проброс порта. Но если он вообще не запущен → смотреть логи.

---

#### 6.4. Проверить firewall / кто реально слушает порт на хосте

На хосте:

```bash
ss -tnlp | grep 5432
```

Если там **ничего** не слушает:
- значит, порт **не проброшен** или контейнер не жив;
- возвращаемся к шагам 6.1–6.2.

Если порт слушает **другая** программа (локальная установка Postgres, etc.):
- конфликт портов:
  - либо остановить локальный Postgres на хосте;
  - либо изменить проброс порта: `"15432:5432"` и подключаться на `localhost:15432`.

---

#### 6.5. Проверить строку подключения и хост

Соединяешься **с хоста**:

- host: `localhost` или `127.0.0.1`
- port: какой ты указал в `-p` / `ports`.

Например:

```bash
psql -h localhost -p 5432 -U postgres
```

Если коннект идёт **из другого контейнера** (внутри compose):
- использовать **имя сервиса** как host:

```yaml
services:
  app:
    environment:
      - DB_HOST=db
      - DB_PORT=5432
  db:
    image: postgres:14
```

Тогда в приложении:
- host = `db`, port = `5432` (НЕ `localhost`).

---

#### 6.6. Быстрый чек-лист "почему нет доступа к 5432"

1. Контейнер жив? → `docker ps`, `docker logs`.
2. Порт проброшен? → `docker ps` → колонка `PORTS` (`5432->5432`?).
3. Нету ли уже чего-то на 5432 на хосте? → `ss/netstat` на хосте.
4. Из какой среды ты коннектишься:
   - из хоста → `localhost:host_port`;
   - из другого контейнера → `service_name:container_port`.
5. Внутри контейнера Postgres реально запущен и слушает 5432? → `docker exec` и `ss/netstat`.

---

#### 6.7. Как ответить на собесе

- "Сначала проверяю, что контейнер с Postgres вообще запущен и не падает (`docker ps`, `docker logs`). Затем смотрю, правильно ли проброшен порт (`-p 5432:5432` и колонка PORTS), нет ли конфликта с локальным Postgres на хосте, и кто реально слушает 5432 на хосте. Если подключаюсь из другого контейнера, использую имя сервиса (`db:5432`), а не `localhost`. Внутри контейнера могу зайти и проверить, что Postgres запущен и слушает порт через `ss/netstat`."


