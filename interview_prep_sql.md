## SQL

1. [Types of JOIN. Name and tell how they differ.](#вопрос-1-types-of-join-name-and-tell-how-they-differ)
2. [HAVING and WHERE distinctions](#вопрос-2-having-and-where-distinctions)
3. [What is a primary key in SQL and why is it important?](#вопрос-3-what-is-a-primary-key-in-sql-and-why-is-it-important)
4. [What is a foreign key and how is it used to establish relationships between tables?](#вопрос-4-what-is-a-foreign-key-and-how-is-it-used-to-establish-relationships-between-tables)
5. [How to build a many-to-many connection?](#вопрос-5-how-to-build-a-many-to-many-connection)
6. [What is the difference between the DELETE and TRUNCATE statements?](#вопрос-6-what-is-the-difference-between-the-delete-and-truncate-statements)
7. [What is normalization and why is it needed? Name the number of forms of normalization](#вопрос-7-what-is-normalization-and-why-is-it-needed-name-the-number-of-forms-of-normalization)
8. [What is a transaction and why is it needed?](#вопрос-8-what-is-a-transaction-and-why-is-it-needed)
9. [ACID. Name the principles and levels of transaction isolation.](#вопрос-9-acid-name-the-principles-and-levels-of-transaction-isolation)
10. [Main types of indexes and how they work](#вопрос-10-main-types-of-indexes-and-how-they-work)
11. [What is a query execution plan and how to view it](#вопрос-11-what-is-a-query-execution-plan-and-how-to-view-it)

---

### Вопрос 1. Types of JOIN. Name and tell how they differ.

#### 1. Основные типы JOIN в SQL

Классический набор:
- **INNER JOIN**
- **LEFT (OUTER) JOIN**
- **RIGHT (OUTER) JOIN**
- **FULL (OUTER) JOIN**
- плюс: `CROSS JOIN`, `SELF JOIN`.

Все они соединяют строки по условию `ON`, но по-разному выбирают **несовпадающие** строки.

Пусть есть:

- `A` (левая таблица)
- `B` (правая таблица)
- условие соединения: `A.id = B.a_id`

---

#### 2. INNER JOIN

```sql
SELECT *
FROM A
INNER JOIN B ON A.id = B.a_id;
```

- Возвращает **только те строки, для которых есть совпадение** и в `A`, и в `B`.
- Несовпадающие строки **отбрасываются**.

Удобно думать:
- пересечение множеств по ключу.

---

#### 3. LEFT (OUTER) JOIN

```sql
SELECT *
FROM A
LEFT JOIN B ON A.id = B.a_id;
-- то же самое: LEFT OUTER JOIN
```

- Берёт **все строки из левой таблицы A**.
- Если для строки из `A` есть совпадающие строки в `B`:
  - они подставляются.
- Если **нет совпадения**:
  - колонки `B` будут `NULL`.

То есть:
- "Все из A, что нашли из B — приклеили, что не нашли — NULL".

---

#### 4. RIGHT (OUTER) JOIN

```sql
SELECT *
FROM A
RIGHT JOIN B ON A.id = B.a_id;
-- RIGHT OUTER JOIN
```

- Симметрично LEFT JOIN, но:
  - берём **все строки из правой таблицы B**;
  - к ним приклеиваем найденные строки из `A`;
  - если совпадения нет — колонки `A` будут `NULL`.

На практике:
- часто можно переписать RIGHT JOIN как LEFT JOIN, просто поменяв местами таблицы.

---

#### 5. FULL (OUTER) JOIN

```sql
SELECT *
FROM A
FULL OUTER JOIN B ON A.id = B.a_id;
```

- Объединяет поведение LEFT и RIGHT:
  - строки, у которых есть совпадение в обоих — соединяются;
  - строки, у которых НЕТ пары в другой таблице — всё равно попадают в результат:
    - с `NULL` в колонках отсутствующей стороны.

То есть:
- **всё из A** + **всё из B**, совмещённое по ключу.

Поддержка:
- не во всех СУБД есть FULL JOIN (например, в MySQL приходится эмулировать через `UNION` двух JOIN-ов).

---

#### 6. CROSS JOIN

```sql
SELECT *
FROM A
CROSS JOIN B;
```

- Декартово произведение:
  - каждая строка из `A` умножается на каждую строку из `B`.
- Обычно эквивалент:

```sql
SELECT *
FROM A, B;
-- без WHERE
```

Использовать осторожно:
- количество строк = `|A| * |B|`.

---

#### 7. SELF JOIN

SELF JOIN — не отдельный тип, а приём, когда таблица **соединяется сама с собой**:

```sql
SELECT e1.id, e1.name, e2.name AS manager_name
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.id;
```

Применяется:
- для иерархий (сотрудник–менеджер, категории–подкатегории и т.п.).

---

#### 8. Как ответить на собесе

- "Основные типы JOIN: `INNER` (только совпадающие строки), `LEFT` (все строки из левой таблицы + совпадения из правой, иначе NULL), `RIGHT` (аналогично, но для правой), `FULL` (объединяет поведение LEFT и RIGHT), `CROSS` (декартово произведение) и `SELF JOIN` (соединение таблицы с самой собой). Разница именно в том, какие **несовпадающие** строки попадают в результат."

---

### Вопрос 2. HAVING and WHERE distinctions

#### 1. WHERE

`WHERE`:
- фильтрует **строки до агрегации**;
- применяется к:
  - исходным строкам таблиц;
  - результатам JOIN-ов;
  - **нельзя** использовать агрегатные функции (`COUNT`, `SUM`, `AVG`, ...) непосредственно.

Пример:

```sql
SELECT *
FROM orders
WHERE amount > 100;
```

Фильтрация записей по полю `amount` до любых группировок.

---

#### 2. HAVING

`HAVING`:
- фильтрует **группы после `GROUP BY`**;
- применяется к:
  - агрегированным значениям;
  - может использовать агрегатные функции (`COUNT`, `SUM`, `AVG`, ...).

Пример:

```sql
SELECT customer_id, COUNT(*) AS cnt
FROM orders
GROUP BY customer_id
HAVING COUNT(*) > 5;
```

Здесь:
- сначала строки группируются по `customer_id`;
- потом `HAVING` убирает группы, где заказов ≤ 5.

---

#### 3. ORDER выполнения запроса (упрощённо)

Логический порядок (важно для понимания WHERE vs HAVING):

1. `FROM` (+ `JOIN`)
2. `WHERE`
3. `GROUP BY`
4. `HAVING`
5. `SELECT`
6. `ORDER BY`
7. `LIMIT/OFFSET`

Поэтому:
- `WHERE` не знает про агрегаты;
- `HAVING` видит уже сгруппированные и агрегированные данные.

---

#### 4. Пример с обоими

Найти клиентов, у которых **больше 5 заказов**, причём мы учитываем только заказы **со статусом 'PAID'**:

```sql
SELECT customer_id, COUNT(*) AS cnt
FROM orders
WHERE status = 'PAID'          -- фильтруем строки до группировки
GROUP BY customer_id
HAVING COUNT(*) > 5;           -- фильтруем группы после
```

---

#### 5. Как ответить на собесе

- "WHERE фильтрует **строки до группировки** и не может использовать агрегатные функции. HAVING фильтрует **результаты группировки**, т.е. группы, и может работать с агрегатами (`COUNT`, `SUM` и т.д.). Часто WHERE используют, чтобы сузить входные данные, а HAVING — чтобы отфильтровать группы после `GROUP BY`."

---

### Вопрос 3. What is a primary key in SQL and why is it important?

#### 1. Что такое первичный ключ (PRIMARY KEY)

**PRIMARY KEY** — это ограничение (constraint) таблицы, которое говорит:
- это **уникальный идентификатор** строки в таблице;
- комбинация столбцов, которая:
  - **уникальна** для каждой строки;
  - **не может быть NULL**.

Обычно:
- таблица имеет **один** primary key;
- он может состоять:
  - из одного столбца (`id`);
  - из нескольких столбцов (составной ключ).

Пример:

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY,
    email VARCHAR(255) NOT NULL,
    name VARCHAR(255)
);
```

Или составной:

```sql
CREATE TABLE order_items (
    order_id BIGINT,
    product_id BIGINT,
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);
```

---

#### 2. Зачем нужен PRIMARY KEY

1. **Уникальная идентификация строк**:
   - без PK сложно однозначно сослаться на строку.

2. **Ссылочная целостность (FOREIGN KEY)**:
   - внешние ключи (`FOREIGN KEY`) указывают на primary/unique key в другой таблице.

```sql
CREATE TABLE orders (
    id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

3. **Индексация**:
   - почти во всех СУБД PRIMARY KEY **автоматически создаёт индекс** по этому полю(ям);
   - это ускоряет поиск по PK и джойны по внешним ключам.

4. **Логическая модель данных**:
   - PK — фундаментальная часть нормализации и хорошего дизайна базы:
     - позволяет избежать дубликатов;
     - делает связи между таблицами чёткими.

---

#### 3. PRIMARY KEY vs UNIQUE

- `PRIMARY KEY`:
  - гарантирует уникальность;
  - **не допускает NULL**;
  - в таблице может быть только **один** PK (но может быть составной).

- `UNIQUE`:
  - тоже гарантирует уникальность;
  - может допускать **один или несколько NULL** (зависит от СУБД, но чаще да);
  - в таблице может быть несколько UNIQUE-ограничений.

PK обычно:
- логический/технический идентификатор записи;
- основа для внешних ключей.

---

#### 4. Естественный vs суррогатный ключ

- **Естественный (natural) ключ**:
  - основан на "реальных" данных (например, `email`, `passport_number`).
  - плюс: отражает бизнес-логику;
  - минус: может меняться, сложнее менять/мигрировать.

- **Суррогатный (surrogate) ключ**:
  - технический ID: `BIGINT AUTO_INCREMENT`, `UUID`;
  - плюс: стабильный, не завязан на бизнес-данные;
  - минус: не несёт бизнес-смысла, но для связей это обычно плюс.

На практике:
- часто используют суррогатный PK (`id BIGINT`) + UNIQUE на бизнес-поле (`email`).

---

#### 5. Как ответить на собесе

- "Primary key — это ограничение, которое определяет уникальный идентификатор строки: значения PK должны быть уникальны и не NULL. Он автоматически индексируется, используется внешними ключами для ссылочной целостности и является основой нормального дизайна схемы. В таблице может быть только один PRIMARY KEY (возможно составной), в отличие от нескольких UNIQUE-ограничений."

---

### Вопрос 4. What is a foreign key and how is it used to establish relationships between tables?

#### 1. Что такое внешний ключ (FOREIGN KEY)

**FOREIGN KEY** — это ограничение (constraint), которое говорит:
- значения в одном столбце (или наборе столбцов) таблицы **должны ссылаться** на существующие значения в **PRIMARY KEY или UNIQUE**-столбце другой (или той же) таблицы.

Пример связи "многие к одному" (заказ → пользователь):

```sql
CREATE TABLE users (
    id   BIGINT PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE orders (
    id        BIGINT PRIMARY KEY,
    user_id   BIGINT NOT NULL,
    amount    DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

Здесь:
- `orders.user_id` — внешний ключ;
- `users.id` — первичный ключ, на который он ссылается.

---

#### 2. Зачем нужен FOREIGN KEY

1. **Ссылочная целостность**:
   - нельзя вставить строку в `orders` с `user_id`, которого нет в `users.id`;
   - нельзя удалить пользователя, если на него ещё ссылаются заказы (если не настроено каскадное поведение).

2. **Гарантия корректности данных**:
   - защита от "висящих ссылок" (orphan records);
   - защита от опечаток в id и т.п.

3. **Документация структуры**:
   - явно показывает связи между таблицами;
   - помогает оптимизатору строить планы запросов.

---

#### 3. Поведение при DELETE / UPDATE (ON DELETE / ON UPDATE)

У FOREIGN KEY можно настроить, что делать при изменении/удалении родительской записи:

- `ON DELETE RESTRICT` / `NO ACTION` (по умолчанию в многих СУБД):
  - запретить удаление родителя, если есть дети.

- `ON DELETE CASCADE`:
  - при удалении родителя удалить и все связанные строки.

- `ON DELETE SET NULL`:
  - при удалении родителя установить внешний ключ в `NULL` (если он допускает NULL).

Пример:

```sql
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
```

---

#### 4. Как ответить на собесе

- "Внешний ключ — это ограничение, которое обеспечивает ссылочную целостность между таблицами: значения в дочерней таблице должны ссылаться на существующие строки в родительской (обычно по первичному ключу). Он не позволяет создавать 'висящие' ссылки и может задавать каскадное поведение при удалении/обновлении (`ON DELETE CASCADE`, `SET NULL` и т.п.)."

---

### Вопрос 5. How to build a many-to-many connection?

#### 1. Суть связи "многие-ко-многим"

Пример: студенты и курсы:
- один студент может записаться на много курсов;
- один курс может иметь много студентов.

На уровне БД:
- **нельзя** сделать это одной FK-колонкой;
- делается через **промежуточную (junction / link / join) таблицу**.

---

#### 2. Структура таблиц для many-to-many

Пример:

```sql
CREATE TABLE students (
    id   BIGINT PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE courses (
    id   BIGINT PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE student_course (
    student_id BIGINT NOT NULL,
    course_id  BIGINT NOT NULL,
    PRIMARY KEY (student_id, course_id),
    FOREIGN KEY (student_id) REFERENCES students(id),
    FOREIGN KEY (course_id)  REFERENCES courses(id)
);
```

Таблица `student_course`:
- каждая строка — одна связь "студент–курс";
- составной PRIMARY KEY `(student_id, course_id)`:
  - не позволяет сделать дубликат связи.

---

#### 3. Как делать выборки

Все курсы студента:

```sql
SELECT c.*
FROM students s
JOIN student_course sc ON s.id = sc.student_id
JOIN courses c         ON sc.course_id = c.id
WHERE s.id = :student_id;
```

Все студенты курса:

```sql
SELECT s.*
FROM courses c
JOIN student_course sc ON c.id = sc.course_id
JOIN students s        ON sc.student_id = s.id
WHERE c.id = :course_id;
```

---

#### 4. Как ответить на собесе

- "Связь многие-ко-многим моделируется через **промежуточную таблицу**: две основные таблицы (например, `students` и `courses`) и третья таблица-линк (`student_course`) с внешними ключами на обе стороны и, как правило, составным первичным ключом `(student_id, course_id)`."

---

### Вопрос 6. What is the difference between the DELETE and TRUNCATE statements?

#### 1. DELETE

```sql
DELETE FROM table_name WHERE condition;
```

Особенности:
- удаляет **строки построчно**, можно задать `WHERE`:
  - без `WHERE` удалит все строки;
  - с `WHERE` — только подходящие.
- обычно:
  - каждая удалённая строка логируется (в журнал транзакций);
  - можно откатить через `ROLLBACK` (если внутри транзакции).
- триггеры `ON DELETE` отрабатывают для каждой строки (зависит от СУБД).

Использование:
- "обычное" удаление данных, когда нужна тонкая фильтрация и/или триггеры.

---

#### 2. TRUNCATE

```sql
TRUNCATE TABLE table_name;
```

Особенности:
- **моментально очищает таблицу целиком**:
  - удаляет все строки;
  - часто также **сбрасывает AUTO_INCREMENT** / последовательности (зависит от СУБД).
- обычно реализован как:
  - **DDL-операция** (упорядочивание/переинициализация сегментов данных);
  - логируется гораздо более компактно, чем DELETE всех строк.
- ограничения:
  - **нельзя использовать с WHERE** — всегда удаляет всё;
  - может быть запрещён, если есть внешние ключи на таблицу (или требуются специальные опции).

По поводу транзакций/отката:
- поведение зависит от СУБД:
  - в PostgreSQL `TRUNCATE` — транзакционный и откатывается;
  - в MySQL/InnoDB тоже можно откатить, если в транзакции;
  - но в целом его часто относят к DDL-операциям, которые могут вести себя иначе, чем DML.

---

#### 3. Сводка отличий

- `DELETE`:
  - может удалять часть строк (через `WHERE`);
  - работает **построчно**;
  - медленнее на больших таблицах;
  - триггеры `ON DELETE` срабатывают;
  - откатывается как обычный DML.

- `TRUNCATE`:
  - всегда удаляет **все** строки;
  - обычно очень быстрый (освобождает/переинициализирует структуры хранения);
  - может сбрасывать автоинкремент;
  - может быть ограничен внешними ключами;
  - не вызывает row-level DELETE-триггеры (часто вызываются statement-level, если есть).

---

#### 4. Как ответить на собесе

- "`DELETE` удаляет строки построчно и может использовать `WHERE` для частичного удаления, при этом каждая строка логируется и триггеры `ON DELETE` срабатывают. `TRUNCATE` моментально очищает таблицу целиком, обычно как DDL-операция, быстрее на больших объёмах, часто сбрасывает автоинкремент и не позволяет использовать `WHERE`."

---

### Вопрос 7. What is normalization and why is it needed? Name the number of forms of normalization

#### 1. Что такое нормализация

**Нормализация** — это процесс проектирования схемы БД, при котором:
- данные разбиваются по таблицам и связям так, чтобы:
  - **минимизировать дублирование (редундантность)**;
  - избежать **аномалий обновления/вставки/удаления**;
  - обеспечить **логическую целостность**.

Идея:
- хранить каждый факт **в одном месте**;
- явно описывать зависимости между атрибутами.

---

#### 2. Зачем нужна нормализация

Проблемы при ненормализованной схеме:
- **аномалия обновления**:
  - одно и то же значение (например, имя города) хранится в десятках строк;
  - нужно обновить везде → риск несогласованности.

- **аномалия вставки**:
  - нельзя добавить некоторую сущность без другой (например, нельзя добавить новый город, пока нет заказов в этом городе).

- **аномалия удаления**:
  - удаляя одну запись (заказ), теряем информацию о другой сущности (о самом клиенте/городе).

Нормализация решает:
- уменьшает риск несогласованных данных;
- делает схему более "чистой" и понятной.

---

#### 3. Основные нормальные формы (NF)

Нормальных форм много (1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF),  
но на собесе чаще всего спрашивают до **3NF**, максимум **BCNF**.

Кратко:

1. **1NF (первая нормальная форма)**:
   - в таблице **нет повторяющихся групп столбцов**;
   - каждое поле — **атомарное** значение (нет массивов/списков в одной ячейке);
   - каждая строка уникальна (есть какой-то ключ).

2. **2NF (вторая нормальная форма)**:
   - нужно быть **в 1NF**;
   - и **каждый неключевой атрибут полностью функционально зависит от всего первичного ключа**, а не от его части.
   - Актуально для **составных PK**:
     - если у таблицы ключ `(A, B)`, то неключевые поля не должны зависеть только от `A` или только от `B`.

3. **3NF (третья нормальная форма)**:
   - нужно быть **в 2NF**;
   - и **нет транзитивных зависимостей**:
     - неключевой атрибут не должен зависеть от другого неключевого атрибута.
   - Пример: если `student(id, name, city, city_zip)`, где `city_zip` зависит от `city` → это транзитивная зависимость → нужно вынести города в отдельную таблицу.

4. **BCNF (Boyce–Codd NF)**:
   - усиление 3NF:
   - каждое **детерминирующее множество атрибутов** должно быть **суперключом**.
   - В проде реже явно проговаривают, но важно понимать, что BCNF ещё строже устраняет аномалии.

Также есть:
- **4NF, 5NF, 6NF** — касаются более сложных зависимостей (многозначных, join-зависимостей), редко спрашиваются на уровне обычного собеса.

---

#### 4. Баланс нормализации и денормализации

На практике:
- OLTP-системы обычно нормализуют **до 3NF/BCNF**;
- для аналитики (OLAP) часто делают **денормализацию**:
  - меньше JOIN-ов, проще запросы, быстрее чтение за счёт дублирования.

Важно:
- нормализация — не цель сама по себе, а инструмент:
  - "сначала делаем нормально (3NF), потом **осознанно** денормализуем под конкретные требования производительности".

---

#### 5. Как ответить на собесе

- "Нормализация — это процесс приведения схемы БД к набору нормальных форм, чтобы уменьшить дублирование данных и избежать аномалий вставки/обновления/удаления. Основные формы: 1NF (атомарные поля и отсутствие повторяющихся групп), 2NF (полная зависимость неключевых атрибутов от всего составного ключа), 3NF (отсутствие транзитивных зависимостей между неключевыми атрибутами), дальше BCNF и более высокие формы используются реже. На практике обычно достаточно 3NF/BCNF, а потом при необходимости делают осознанную денормализацию."

---

### Вопрос 8. What is a transaction and why is it needed?

#### 1. Что такое транзакция

**Транзакция** — это логическая единица работы с БД, которая:
- объединяет несколько операций (INSERT/UPDATE/DELETE/SELECT ... FOR UPDATE и т.п.) в один **атомарный** блок;
- либо выполняется **вся**, либо **не выполняется вообще** (откат).

Пример жизненного сценария:
- перевод денег с одного счёта на другой:
  1. списать сумму со счёта А;
  2. зачислить сумму на счёт B;
  3. если что-то пошло не так — откатить обе операции.

---

#### 2. Основные операции с транзакциями

Типичный цикл:

```sql
BEGIN TRANSACTION;  -- или START TRANSACTION

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT;  -- фиксируем изменения
-- или ROLLBACK; -- откатываем все изменения в рамках транзакции
```

Команды:
- `BEGIN` / `START TRANSACTION` — начало;
- `COMMIT` — зафиксировать все изменения;
- `ROLLBACK` — откатить изменения до начала транзакции (или до savepoint-а).

Во многих драйверах:
- по умолчанию **autocommit = true**:
  - каждая команда — своя маленькая транзакция;
  - для ручного контроля autocommit надо выключать.

---

#### 3. Зачем нужны транзакции

Основные цели:
- **Целостность данных**:
  - сложные операции выполняются полностью или не выполняются.
- **Согласованность**:
  - данные не оказываются в "полу-состоянии" (например, деньги списались, но не пришли).
- **Изоляция конкурентных операций**:
  - различные пользователи/сервисы не мешают друг другу и видят консистентное состояние.

Это и есть база для ACID (см. следующий вопрос).

---

#### 4. Как ответить на собесе

- "Транзакция — это единица работы с базой, которая группирует несколько операций так, что они выполняются атомарно: либо все, либо ни одной. Она нужна для поддержания целостности и согласованности данных при ошибках и конкурентном доступе; управляется командами BEGIN/COMMIT/ROLLBACK."

---

### Вопрос 9. ACID. Name the principles and levels of transaction isolation.

#### 1. ACID-принципы

ACID = **Atomicity, Consistency, Isolation, Durability**:

1. **Atomicity (атомарность)**:
   - транзакция — неделимая единица:
     - либо все изменения применяются (COMMIT),
     - либо ни одно (ROLLBACK).

2. **Consistency (согласованность)**:
   - транзакция переводит базу из **одного согласованного состояния** в другое;
   - все бизнес- и целостностные ограничения (PK, FK, CHECK и т.п.) остаются выполнены.

3. **Isolation (изолированность)**:
   - параллельные транзакции **не должны мешать** друг другу;
   - результат их одновременного выполнения должен быть эквивалентен некоторому последовательному выполнению (в сильной изоляции).

4. **Durability (надёжность)**:
   - после COMMIT изменения **не потеряются**, даже при падении сервера (при условии, что данные записаны в журнал/на диск).

---

#### 2. Аномалии конкурентного доступа

Типичные проблемы, которые должна решать изоляция:

- **Dirty read**:
  - транзакция читает **не зафиксированные** изменения другой транзакции.

Пример (упрощённо, READ UNCOMMITTED):

```sql
-- Транзакция T1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- ещё не COMMIT

-- Транзакция T2 (в другом сеансе)
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT balance FROM accounts WHERE id = 1;  -- видит уже уменьшенный баланс

-- Если T1 сделает ROLLBACK, T2 прочитала данные, которых "никогда не было".
```

- **Non-repeatable read**:
  - один и тот же SELECT внутри транзакции возвращает **разные данные** (кто-то изменил строки и закоммитил).

Пример (READ COMMITTED):

```sql
-- Транзакция T1
BEGIN;
SELECT balance FROM accounts WHERE id = 1;  -- получаем 100

-- Транзакция T2
BEGIN;
UPDATE accounts SET balance = 200 WHERE id = 1;
COMMIT;

-- Снова T1
SELECT balance FROM accounts WHERE id = 1;  -- уже 200 (non-repeatable read)
COMMIT;
```

- **Phantom read**:
  - повторный SELECT по одному и тому же условию возвращает **другой набор строк** (появились/исчезли новые строки, удовлетворяющие условию).

Пример:

```sql
-- Транзакция T1
BEGIN;
SELECT * FROM orders WHERE amount > 100;  -- видим 10 строк

-- Транзакция T2
BEGIN;
INSERT INTO orders (id, amount) VALUES (999, 150);
COMMIT;

-- Снова T1
SELECT * FROM orders WHERE amount > 100;  -- теперь 11 строк (появился "фантом")
COMMIT;
```

---

#### 2.1. Коротко: non-repeatable vs phantom

- **Non-repeatable read**:
  - речь про **одну и ту же строку**;
  - между первым и вторым чтением её поля изменились (и это изменение закоммичено другой транзакцией).

- **Phantom read**:
  - речь про **множество строк по условию** (`WHERE amount > 100`);
  - между первым и вторым чтением **набор строк** изменился:
    - появились новые строки, подходящие под условие;
    - или некоторые строки исчезли.

Можно думать так:
- non-repeatable — "та же строка, но другие данные";
- phantom — "другие строки начали/перестали попадать в выборку".

---

#### 2.2. Замечание про реализацию (MVCC)

В реальных СУБД (PostgreSQL, MySQL InnoDB и др.) уровни изоляции часто реализованы через **MVCC** (multi-version concurrency control) и **снимки** (snapshot):

- В PostgreSQL `REPEATABLE READ` даёт эффект **snapshot isolation**:
  - транзакция видит "снимок" данных на момент начала;
  - фактически там **нет** ни non-repeatable read, ни phantom read.

- В MySQL InnoDB `REPEATABLE READ` тоже реализован через MVCC, и phantom’ы в типичных сценариях сильно подавляются.

НО на собесах обычно хотят, чтобы ты знал **теоретическую картинку стандарта SQL**:
- READ COMMITTED — допускает non-repeatable и phantom;
- REPEATABLE READ — блокирует non-repeatable, но теоретически допускает phantom;
- SERIALIZABLE — блокирует и non-repeatable, и phantom.


---

#### 3. Уровни изоляции транзакций

Стандарт SQL определяет 4 основных уровня (от слабого к сильному):

1. **READ UNCOMMITTED**:
   - допускает **dirty reads**;
   - практически не используется в нормальных системах.

2. **READ COMMITTED**:
   - **нет dirty reads** (видим только закоммиченные данные);
   - но возможны:
     - non-repeatable read;
     - phantom read.
   - Часто уровень по умолчанию (Oracle, PostgreSQL).

3. **REPEATABLE READ**:
   - **нет dirty read**;
   - **нет non-repeatable read** (одни и те же строки читаются одинаково внутри транзакции);
   - возможны **phantom read** (набор строк по условию может измениться).
   - В MySQL InnoDB по умолчанию REPEATABLE READ, но с MVCC реализацией, где phantom-ы могут быть частично подавлены.

4. **SERIALIZABLE**:
   - самая сильная изоляция;
   - транзакции выполняются так, как будто идут **строго последовательно**;
   - нет dirty/non-repeatable/phantom;
   - цена — возможны блокировки, конфликты, откаты, падение пропускной способности.

На практике:
- READ COMMITTED или REPEATABLE READ чаще всего достаточно;
- SERIALIZABLE используют для критичных инвариантов, точных отчётов.

---

#### 4. Как ответить на собесе

- "ACID: атомарность, согласованность, изолированность и надёжность — определяют поведение транзакций. Уровни изоляции: READ UNCOMMITTED (допускает dirty read), READ COMMITTED (нет dirty read), REPEATABLE READ (дополнительно нет non-repeatable read) и SERIALIZABLE (максимальная изоляция, без phantoms, но с высокой ценой по производительности)."

---

### Вопрос 10. Main types of indexes and how they work

#### 1. Что такое индекс

**Индекс** — это вспомогательная структура данных (обычно B-tree или хеш-структура),  
которая позволяет СУБД **быстрее находить строки** по значениям столбцов.

Аналог: алфавитный указатель в книге вместо линейного перелистывания всех страниц.

---

#### 2. B-Tree / B+Tree индексы

Самый распространённый тип индекса в реляционных БД.

Особенности:
- отсортированная древовидная структура (B-tree/B+tree);
- эффективен для:
  - `=`, `<`, `>`, `BETWEEN`, `LIKE 'prefix%'`;
  - сортировок (`ORDER BY`) и диапазонных запросов.

Пример создания:

```sql
CREATE INDEX idx_users_email ON users(email);
```

Работа:
- при поиске по `email = 'a@b.com'` движок идёт по дереву (логарифмическая глубина), находит позицию и затем читает соответствующие строки.

Составные индексы:

```sql
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);
```

Правило:
- индекс "подходит" под запросы:
  - по левому префиксу: `user_id`, `(user_id, created_at)`;
  - не подойдёт для запроса только по `created_at` (без `user_id`), если индекс `(user_id, created_at)`.

---

#### 3. Hash-индексы

Используются в некоторых СУБД/движках (например, в PostgreSQL есть `USING HASH`, в MySQL — специфические движки).

Особенности:
- основаны на хэш-таблице;
- очень быстры для точного сравнения `=` (key → bucket);
- **не подходят** для диапазонных запросов (`<`, `>`, `BETWEEN`, `ORDER BY`).

Использование:
- узкоспециализировано; чаще B-tree достаточно.

---

#### 4. Bitmap-индексы

Чаще в аналитических/колоночных БД.

Особенности:
- для каждого возможного значения столбца хранится битовая маска строк, где оно встречается;
- очень эффективны для колонок:
  - с небольшим числом уникальных значений (low cardinality);
  - и частыми логическими комбинациями (`AND/OR` условий).

Пример:
- колонка `status` со значениями `NEW`, `PAID`, `CANCELLED`.

---

#### 5. Clustered vs non-clustered (в терминах СУБД вроде SQL Server/MySQL InnoDB)

- **Clustered index**:
  - определяет **физический порядок хранения** строк в таблице;
  - обычно в InnoDB это **PRIMARY KEY**;
  - у таблицы может быть только **один** clustered index.

- **Non-clustered index**:
  - отдельная структура, хранящая:
    - значение индексируемого столбца + указатель на строку (или PK);
  - можно иметь **много** таких индексов.

Понимание:
- PRIMARY KEY обычно — clustered (особенно в InnoDB);
- остальные индексы — non-clustered / secondary.

---

#### 6. Цена индексов

Индексы ускоряют **чтение**, но:
- замедляют **запись** (`INSERT`, `UPDATE`, `DELETE`):
  - нужно обновлять сами индексы;
- занимают место на диске и в памяти;
- плохо подобранные индексы могут **не использоваться** оптимизатором.

Поэтому:
- нужно находить баланс:
  - индексировать колонки, которые часто используются в `WHERE`, `JOIN`, `ORDER BY`;
  - не делать индекс "на всё подряд".

---

#### 7. Как ответить на собесе

- "Основной тип индекса в SQL-БД — B-tree/B+tree, который хорош для точного поиска и диапазонных запросов. Есть также hash-индексы (эффективны только для `=`), bitmap-индексы (полезны в аналитике для колонок с малой кардинальностью), clustered и non-clustered индексы. Индексы ускоряют чтение, но замедляют записи и занимают место, поэтому их выбирают осознанно под частые запросы."

---

### Вопрос 11. What is a query execution plan and how to view it

#### 1. Что такое план выполнения запроса

**Query execution plan** — это описание того, **как СУБД собирается выполнить запрос**:
- какие индексы будет использовать;
- в каком порядке будут джойны;
- какие операции (`Seq Scan`, `Index Scan`, `Nested Loop`, `Hash Join`, `Merge Join` и т.д.) будут выполнены;
- оценки стоимости / количества строк.

Это ключевой инструмент для:
- диагностики **производительности** запросов;
- проверки, используются ли нужные индексы;
- понимания, почему запрос тормозит.

---

#### 2. Как посмотреть план в разных СУБД (общие принципы)

Почти во всех СУБД используется ключевое слово `EXPLAIN`:

```sql
EXPLAIN
SELECT ...
```

В более подробном виде:

```sql
EXPLAIN ANALYZE
SELECT ...
```

или:

```sql
EXPLAIN (ANALYZE, BUFFERS, VERBOSE)
SELECT ...
```

Зависит от СУБД:

- **PostgreSQL**:
  - `EXPLAIN SELECT ...;`
  - `EXPLAIN ANALYZE SELECT ...;` — выполняет запрос и показывает **фактические** времена и числа строк.

- **MySQL**:
  - `EXPLAIN SELECT ...;`
  - `EXPLAIN ANALYZE SELECT ...;` (в новых версиях).

- **SQL Server**:
  - "Display Estimated Execution Plan" / "Include Actual Execution Plan" в SSMS;
  - или `SET SHOWPLAN_XML ON` / `SET STATISTICS PROFILE ON`.

---

#### 3. Что смотреть в плане

Основные моменты:

- Тип сканирования:
  - **Seq Scan / Table Scan**:
    - полный проход по таблице (может быть ОК на маленьких таблицах, но плохо на больших);
  - **Index Scan / Index Seek**:
    - использование индекса для поиска поднабора строк.

- Операции JOIN:
  - **Nested Loop** — хорошо, когда одна таблица маленькая, а к другой есть индекс;
  - **Hash Join** — хорошо для больших наборов при наличии памяти;
  - **Merge Join** — когда входы отсортированы.

- Оценка количества строк и стоимости:
  - большие расхождения между ожидаемым и фактическим количеством строк → плохая статистика.

- Используемые индексы:
  - проверять, что запрос действительно задействует нужные индексы.

---

#### 4. Зачем это нужно на собесе

Важно показать:
- что ты умеешь **не только писать запросы**, но и **разбирать, почему они медленные**;
- что знаешь, как:
  - включить `EXPLAIN/EXPLAIN ANALYZE`;
  - прочитать, есть ли полный скан таблицы там, где нужно было использовать индекс;
  - решить, где добавить/изменить индекс, как переписать запрос.

---

#### 5. Как ответить на собесе

- "План выполнения запроса — это то, как оптимизатор СУБД реально собирается выполнять запрос: какие индексы использовать, какие типы сканов и JOIN-ов, в каком порядке. Его можно посмотреть через `EXPLAIN`/`EXPLAIN ANALYZE` (в PostgreSQL, MySQL) или соответствующие инструменты в SQL Server. Анализ плана позволяет понять, почему запрос работает медленно, и принять решение об индексации или переписывании запроса."


